#!/usr/bin/env python3
"""
Keboola-specific utilities for table operations and state management.
"""
import datetime
from typing import Optional, List, Dict, Any
from keboola.component import CommonInterface
from src.config import logger


def detect_time_period_from_state(ci: CommonInterface, days: int = 30) -> tuple[datetime.datetime, datetime.datetime]:
    """Detect time period using Keboola state file."""
    try:
        # Try to get last processed date from state
        state = ci.get_state_file()

        if state and 'last_processed_date' in state:
            last_date = datetime.datetime.fromisoformat(state['last_processed_date'])
            today = datetime.datetime.now()
            logger.info(f"Using last processed date from state: {last_date}")
            return last_date, today
        else:
            # No state found, use default
            today = datetime.datetime.now()
            start_date = today - datetime.timedelta(days=days)
            logger.info(f"No state found, using last {days} days")
            return start_date, today

    except Exception as e:
        logger.warning(f"Error reading state file: {e}, using default")
        today = datetime.datetime.now()
        start_date = today - datetime.timedelta(days=days)
        return start_date, today


def update_state_file(ci: CommonInterface, last_processed_date: datetime.datetime) -> None:
    """Update state file with last processed date."""
    try:
        state = ci.get_state_file() or {}
        state['last_processed_date'] = last_processed_date.isoformat()
        state['last_run'] = datetime.datetime.now().isoformat()
        ci.write_state_file(state)
        logger.info(f"Updated state file with date: {last_processed_date}")
    except Exception as e:
        logger.error(f"Error updating state file: {e}")


def generate_release_note_content(entry: Dict[str, Any]) -> str:
    """Generate release note content in markdown format."""
    content = f"""# {entry['component_name']} {entry['tag_name']}

_Released on {entry['date'].strftime('%Y-%m-%d') if hasattr(entry['date'], 'strftime') else str(entry['date'])}_

**Component:** [{entry['component_name']}](https://github.com/keboola/{entry['repo_name']})  
**Tag:** [{entry['tag_name']}]({entry['tag_url']})  
**Stage:** {entry['component_stage']}

"""

    if entry.get('ai_description'):
        content += f"""## Change log (AI generated):
{entry['ai_description']}

"""
    else:
        content += """## Change log (AI generated):
*AI summary not available - AI model was not configured or failed to generate summary*

"""

    if entry.get('changes'):
        content += "## Changes:\n"
        seen_titles = []
        for change in entry['changes']:
            if change.get('title') and change['title'] not in seen_titles:
                change_line = f"- {change['title']}"
                if change.get('number'):
                    change_line += f" ([#{change['number']}]({change.get('url', '')}))"
                content += change_line + "\n"
                seen_titles.append(change['title'])

        content += f"\n[Compare on GitHub](https://github.com/{entry['github_organization']}/{entry['repo_name']}/compare/{entry['previous_tag']}...{entry['tag_name']})\n\n"

    if entry.get('component_details'):
        content += "## Component Information\n"
        content += f"**Type:** {entry['component_details'].get('type', 'Unknown')}\n"
        content += f"**Name:** {entry['component_details'].get('name', 'Unknown')}\n"

        if entry['component_details'].get('description'):
            content += f"**Description:** {entry['component_details']['description']}\n"

        if entry['component_details'].get('documentationUrl'):
            content += f"**Documentation:** [Link]({entry['component_details']['documentationUrl']})\n"

        content += "\n"

    content += f"""---
_Generated by Release Notes Generator on {datetime.datetime.now(datetime.timezone.utc).strftime('%Y-%m-%d %H:%M:%S')}_"""

    return content


def save_release_to_table(ci: CommonInterface, release_data: Dict[str, Any], table_name: str = "releases") -> bool:
    """Save a release to the Keboola table with generated content."""
    logger.info(
        f"Starting save_release_to_table for {release_data.get('component_name', 'unknown')} {release_data.get('tag_name', 'unknown')}")
    try:
        # Generate release note content
        logger.info(
            f"Generating release note content for {release_data.get('component_name', 'unknown')} {release_data.get('tag_name', 'unknown')}")
        try:
            release_content = generate_release_note_content(release_data)
            logger.info(f"Generated release note content (length: {len(release_content)})")
        except Exception as content_error:
            logger.error(f"Error generating release note content: {content_error}")
            raise

                # Prepare data for table
        table_data = {
            'release_date': release_data['date'].isoformat() if hasattr(release_data['date'], 'isoformat') else str(
                release_data['date']),
            'component_id': release_data['component_name'],  # Changed from component_name to component_id
            'component_stage': release_data['component_stage'],
            'tag_name': release_data['tag_name'],
            'previous_tag': release_data['previous_tag'],
            'repo_name': release_data['repo_name'],
            'github_url': release_data['tag_url'],
            'ai_summary': release_data.get('ai_description',
                                            'AI summary not available - AI model was not configured or failed to generate summary'),
            'difference_link': f"https://github.com/{release_data.get('github_organization', 'keboola')}/{release_data['repo_name']}/compare/{release_data['previous_tag']}...{release_data['tag_name']}",
            'developer_portal_link': f"https://components.keboola.com/components/{release_data['component_name']}",
            'component_type': release_data.get('component_details', {}).get('type', ''),
            'component_description': release_data.get('component_details', {}).get('description', ''),
            'documentation_url': release_data.get('component_details', {}).get('documentationUrl', ''),
            'release_note_content': release_content,
            'generated_at': datetime.datetime.now().isoformat()
        }

        # Debug logging
        logger.info(f"Preparing table data for {release_data['component_name']} {release_data['tag_name']}:")
        logger.info(f"  - component_id: {table_data['component_id']}")
        logger.info(f"  - difference_link: {table_data['difference_link']}")
        logger.info(f"  - developer_portal_link: {table_data['developer_portal_link']}")

        # Define table columns
        columns = list(table_data.keys())

        # Create table definition
        logger.info(f"Creating table definition for {table_name}.csv")
        try:
            out_table = ci.create_out_table_definition(
                f'{table_name}.csv',
                columns=columns,
                destination=f'out.c-cf-release-notes.{table_name}',
                primary_key=['component_id', 'tag_name'],  # Changed from component_name to component_id
                incremental=True,
                has_header=True
            )
            logger.info(f"Table definition created, full_path: {out_table.full_path}")
        except Exception as table_error:
            logger.error(f"Error creating table definition: {table_error}")
            raise

        # Write data to CSV file
        import csv
        import os
        csv_path = out_table.full_path

        # Check if file exists and has content to determine if we need to write header
        file_exists = os.path.exists(csv_path)
        file_has_content = False

        if file_exists:
            # Check if file has content (not just header)
            try:
                with open(csv_path, 'r', encoding='utf-8') as csvfile:
                    reader = csv.reader(csvfile)
                    rows = list(reader)
                    # If we have at least 1 row (header), file has content
                    file_has_content = len(rows) >= 1
            except Exception:
                # If we can't read the file, assume it's empty
                file_has_content = False

        # Check for duplicates before writing
        is_duplicate = False
        if file_exists and file_has_content:
            try:
                with open(csv_path, 'r', encoding='utf-8') as csvfile:
                    reader = csv.DictReader(csvfile)
                    for row in reader:
                        # Check if this exact release already exists
                        if (row.get('component_id') == table_data['component_id'] and
                                row.get('tag_name') == table_data['tag_name']):
                            logger.info(
                                f"Duplicate found: {table_data['component_id']} {table_data['tag_name']} already exists in table")
                            is_duplicate = True
                            break
                    logger.info(
                        f"Checked {sum(1 for _ in csv.DictReader(open(csv_path, 'r', encoding='utf-8')))} existing rows for duplicates")
            except Exception as e:
                logger.warning(f"Error checking for duplicates: {e}")
        else:
            logger.info(f"File doesn't exist or is empty, no duplicate check needed")

        # Only write if not a duplicate
        if not is_duplicate:
            # Append data to CSV file
            with open(csv_path, 'a', newline='', encoding='utf-8') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=columns)

                # Write header only if file doesn't exist or is empty
                if not file_exists or not file_has_content:
                    writer.writeheader()

                writer.writerow(table_data)

            # Write manifest
            logger.info(f"Writing manifest for {table_name}.csv")
            try:
                ci.write_manifest(out_table)
                logger.info(f"Manifest written successfully")
            except Exception as manifest_error:
                logger.warning(f"Error writing manifest: {manifest_error}")
                # Continue anyway, the CSV file was written successfully

            logger.info(
                f"Successfully saved release {release_data['component_name']} {release_data['tag_name']} to table with content (component_id: {release_data['component_name']})")
            return True
        else:
            logger.info(f"Skipped duplicate release {release_data['component_name']} {release_data['tag_name']}")
            return False

    except Exception as e:
        logger.error(f"Error saving release to table: {e}")
        logger.error(f"Exception details: {type(e).__name__}: {str(e)}")
        import traceback
        logger.error(f"Traceback: {traceback.format_exc()}")
        return False
