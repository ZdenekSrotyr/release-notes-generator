#!/usr/bin/env python3
"""
Keboola-specific utilities for table operations and state management.
"""
import datetime
import json
from typing import Optional, List, Dict, Any
from keboola.component import CommonInterface
from src.config import logger


def detect_time_period_from_state(ci: CommonInterface, days: int = 30) -> tuple[datetime.datetime, datetime.datetime]:
    """Detect time period using Keboola state file."""
    try:
        # Try to get last processed date from state
        state = ci.get_state_file()
        
        if state and 'last_processed_date' in state:
            last_date = datetime.datetime.fromisoformat(state['last_processed_date'])
            today = datetime.datetime.now()
            logger.info(f"Using last processed date from state: {last_date}")
            return last_date, today
        else:
            # No state found, use default
            today = datetime.datetime.now()
            start_date = today - datetime.timedelta(days=days)
            logger.info(f"No state found, using last {days} days")
            return start_date, today
            
    except Exception as e:
        logger.warning(f"Error reading state file: {e}, using default")
        today = datetime.datetime.now()
        start_date = today - datetime.timedelta(days=days)
        return start_date, today


def update_state_file(ci: CommonInterface, last_processed_date: datetime.datetime) -> None:
    """Update state file with last processed date."""
    try:
        state = ci.get_state_file() or {}
        state['last_processed_date'] = last_processed_date.isoformat()
        state['last_run'] = datetime.datetime.now().isoformat()
        ci.write_state_file(state)
        logger.info(f"Updated state file with date: {last_processed_date}")
    except Exception as e:
        logger.error(f"Error updating state file: {e}")


def generate_release_note_content(entry: Dict[str, Any]) -> str:
    """Generate release note content in markdown format."""
    content = f"""# {entry['component_name']} {entry['tag_name']}

_Released on {entry['date'].strftime('%Y-%m-%d')}_

**Component:** [{entry['component_name']}](https://github.com/keboola/{entry['repo_name']})  
**Tag:** [{entry['tag_name']}]({entry['tag_url']})  
**Stage:** {entry['component_stage']}

"""

    if entry.get('ai_description'):
        content += f"""## Change log (AI generated):
{entry['ai_description']}

"""
    else:
        content += """## Change log (AI generated):
*AI summary not available - AI model was not configured or failed to generate summary*

"""

    if entry['changes']:
        content += "## Changes:\n"
        seen_titles = []
        for change in entry['changes']:
            if change.get('title') and change['title'] not in seen_titles:
                change_line = f"- {change['title']}"
                if change.get('number'):
                    change_line += f" ([#{change['number']}]({change.get('url', '')}))"
                content += change_line + "\n"
                seen_titles.append(change['title'])
        
        content += f"\n[Compare on GitHub](https://github.com/{entry['github_organization']}/{entry['repo_name']}/compare/{entry['previous_tag']}...{entry['tag_name']})\n\n"

    if entry.get('component_details'):
        content += "## Component Information\n"
        content += f"**Type:** {entry['component_details'].get('type', 'Unknown')}\n"
        content += f"**Name:** {entry['component_details'].get('name', 'Unknown')}\n"
        
        if entry['component_details'].get('description'):
            content += f"**Description:** {entry['component_details']['description']}\n"
        
        if entry['component_details'].get('documentationUrl'):
            content += f"**Documentation:** [Link]({entry['component_details']['documentationUrl']})\n"
        
        content += "\n"

    content += f"""---
_Generated by Release Notes Generator on {datetime.datetime.now(datetime.timezone.utc).strftime('%Y-%m-%d %H:%M:%S')}_"""

    return content


def save_release_to_table(ci: CommonInterface, release_data: Dict[str, Any], table_name: str = "releases") -> bool:
    """Save a release to the Keboola table with generated content."""
    try:
        # Generate release note content
        release_content = generate_release_note_content(release_data)
        
        # Prepare data for table
        table_data = {
            'release_date': release_data['date'].isoformat(),
            'component_id': release_data['component_name'],  # Changed from component_name to component_id
            'component_stage': release_data['component_stage'],
            'tag_name': release_data['tag_name'],
            'previous_tag': release_data['previous_tag'],
            'repo_name': release_data['repo_name'],
            'github_url': release_data['tag_url'],
            'ai_summary': release_data.get('ai_description', 'AI summary not available - AI model was not configured or failed to generate summary'),
            'changes_count': len(release_data.get('changes', [])),  # Added .get() with default empty list
            'changes_list': json.dumps([change.get('title', '') for change in release_data.get('changes', [])]),  # Added .get() with default empty list
            'component_type': release_data.get('component_details', {}).get('type', ''),
            'component_description': release_data.get('component_details', {}).get('description', ''),
            'documentation_url': release_data.get('component_details', {}).get('documentationUrl', ''),
            'release_note_content': release_content,
            'generated_at': datetime.datetime.now().isoformat()
        }
        
        # Debug logging
        logger.info(f"Preparing table data for {release_data['component_name']} {release_data['tag_name']}:")
        logger.info(f"  - changes_count: {table_data['changes_count']}")
        logger.info(f"  - changes_list: {table_data['changes_list'][:100]}...")  # Show first 100 chars
        logger.info(f"  - component_id: {table_data['component_id']}")
        
        # Define table columns
        columns = list(table_data.keys())
        
        # Create table definition
        out_table = ci.create_out_table_definition(
            f'{table_name}.csv',
            columns=columns,
            destination=f'out.c-cf-release-notes.{table_name}',
            primary_key=['component_id', 'tag_name'],  # Changed from component_name to component_id
            incremental=True
        )
        
        # Write data to CSV file
        import csv
        import os
        csv_path = out_table.full_path
        
        # Check if file exists and has content to determine if we need to write header
        file_exists = os.path.exists(csv_path)
        file_has_content = False
        
        if file_exists:
            # Check if file has content (not just header)
            try:
                with open(csv_path, 'r', encoding='utf-8') as csvfile:
                    reader = csv.reader(csvfile)
                    rows = list(reader)
                    # If we have at least 1 row (header), file has content
                    file_has_content = len(rows) >= 1
            except Exception:
                # If we can't read the file, assume it's empty
                file_has_content = False
        
        # Check for duplicates before writing
        is_duplicate = False
        if file_exists and file_has_content:
            try:
                with open(csv_path, 'r', encoding='utf-8') as csvfile:
                    reader = csv.DictReader(csvfile)
                    for row in reader:
                        # Check if this exact release already exists
                        if (row.get('component_id') == table_data['component_id'] and 
                            row.get('tag_name') == table_data['tag_name']):
                            logger.info(f"Duplicate found: {table_data['component_id']} {table_data['tag_name']} already exists in table")
                            is_duplicate = True
                            break
            except Exception as e:
                logger.warning(f"Error checking for duplicates: {e}")
        
        # Only write if not a duplicate
        if not is_duplicate:
            # Append data to CSV file
            with open(csv_path, 'a', newline='', encoding='utf-8') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=columns)
                
                # Write header only if file doesn't exist or is empty
                if not file_exists or not file_has_content:
                    writer.writeheader()
                
                writer.writerow(table_data)
            
            logger.info(f"Saved release {release_data['component_name']} {release_data['tag_name']} to table with content (component_id: {release_data['component_name']})")
            return True
        else:
            logger.info(f"Skipped duplicate release {release_data['component_name']} {release_data['tag_name']}")
            return False
        
        # Write manifest
        ci.write_manifest(out_table)
        
    except Exception as e:
        logger.error(f"Error saving release to table: {e}")
        return False 